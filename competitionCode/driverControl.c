#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lineSensor,     sensorLineFollower)
#pragma config(Sensor, in2,    gyroSensor,     sensorGyro)
#pragma config(Sensor, I2C_1,  leftShooterEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  driveFrontLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  driveRearLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  driveRearRightEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  driveFrontRightEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  rightShooterEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           magazine,      tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port3,           shooterLeft,   tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           driveFrontLeft, tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port5,           driveFrontRight, tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_5, 1000)
#pragma config(Motor,  port6,           driveRearLeft, tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port7,           driveRearRight, tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port8,           shooterRight,  tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_6, 1000)
#pragma config(Motor,  port9,           intake,        tmotorVex393HighSpeed, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

 //#include "serialCortex.h"

// --------- GLOBAL VARIABLES ---------//
	int shooterSpeedGoal = 80;
	int shooterLeftSpeed = 80;
	int shooterRightSpeed = 80;
	int shooterLeftSpeedPrevious = 80;
	int shooterRightSpeedPrevious = 80;
	int derivative = 5;
	int proportion = 5;
	int leftEncoderSpeed;
	int rightEncoderSpeed;
	int leftEncoderError;
	int rightEncoderError;
	int leftVelocity = 80;				// initial speeds
	int rightVelocity = 80;


////Pivoting is for the gyro
//void pivotClockwise (int goRight)    {
//	while(SensorValue[driveFrontRightEncoder] < goRight)   {
//  	motor[driveFrontRight] = -40;	// 5
//		motor[driveRearRight] = -40;
//		motor[driveFrontLeft] = 40;
//		motor[driveRearLeft] = 40;
//    }
//}

//void pivotCounterClockwise (int goLeft)  {
//    while(SensorValue[driveFrontLeftEncoder] < goLeft)    {
//		  motor[driveFrontRight] = 40;	// 5
//			motor[driveRearRight] = 40;
//			motor[driveFrontLeft] = -40;	// 5
//			motor[driveRearLeft] = -40;
//    }
//}

//Turning is for the line sensor

void turnClockwise (int goRight)    {
	while(SensorValue[driveFrontRightEncoder] < goRight)   {
  	motor[driveFrontRight] = 0;	// 5
		motor[driveRearRight] = 0;
		motor[driveFrontLeft] = 40;	// 5
		motor[driveRearLeft] = 40;
    }
}

void turnCounterClockwise (int goLeft)  {
    while(SensorValue[driveFrontLeftEncoder] < goLeft)    {
		  motor[driveFrontRight] = 40;	// 5
			motor[driveRearRight] = 40;
			motor[driveFrontLeft] = 0;	// 5
			motor[driveRearLeft] = 0;
    }
}

void goForward (int goCount)    {
    while(SensorValue[driveFrontLeftEncoder] < goCount || SensorValue[driveFrontRightEncoder] < goCount)   {
		  motor[driveFrontRight] = 56;	// 5
			motor[driveRearRight] = 56;
			motor[driveFrontLeft] = 102;	// 5
			motor[driveRearLeft] = 102;
		}
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

// task autonomous()	{

task autonomous()	{		// void autonomous()
	// StartTask(serialRxTask);	//gyroSensor

	int autoShooterSpeedGoal = 100;
	autoShooterStartSoft(autoShooterSpeedGoal);

	ClearTimer(T1);	// Clear Timer
	while (time1[T1] < 5)	{		//GO FORWARD for 5 SECONDS????
		goForward(100);
	}

	while (true) {		// LINE SENSOR CODE
		motor[intake] = 100;

		if (SensorValue(lineSensor) < 1500) {           	 // 128 to 255 is left side
			turnCounterClockwise(40);
		}
		else if (SensorValue(lineSensor) <= 1500 && SensorValue(lineSensor) >= 1750)	{
			goForward(40);
		}
		else if (SensorValue(lineSensor) < 1750) {           // 0 to 127 is the right side.
			turnClockwise(40);
		}
		else    {   // BREAK
			motor[driveFrontRight] = 0;
			motor[driveRearRight] = 0;
			motor[driveFrontLeft] = 0;
			motor[driveRearLeft] = 0;
		}   // end Line Sensor statement

		autoShooterStartSoft(autoShooterSpeedGoal);

	}   // end  while(true)
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void userDrive()	{
	//---------------------MOVEMENT VARIABLES------------------//
	int stick_1x = 0;
	int stick_3y = 0;
	int stick_4x = 0;
	int stick_2y = 0;
	int threshold = 25;			// If value is in deadzone set to zero else set to channel value.
	//---------------------MOVEMENT CONTROLLERS------------------//
	if (abs(vexRT[Ch3]) > threshold)			//Left Joystick Y
		stick_3y = vexRT[Ch3];
	else
		stick_3y = 0;
	if (abs(vexRT[Ch4]) > threshold) 		//Left Joystick X
		stick_4x = vexRT[Ch4];
	else
		stick_4x = 0;
	if (abs(vexRT[Ch1]) > threshold)			//Right Joystick X
		stick_1x = vexRT[Ch1];
	else
		stick_1x = 0;
	if (abs(vexRT[Ch2])>threshold)				//Right Joystick Y
		stick_2y = vexRT[Ch2];
	else
		stick_2y = 0;

	motor[driveFrontRight] = stick_3y - stick_1x - stick_4x + stick_2y;
	motor[driveRearRight] = stick_3y - stick_1x + stick_4x + stick_2y;
	motor[driveFrontLeft] = stick_3y + stick_1x + stick_4x + stick_2y;
	motor[driveRearLeft] = stick_3y + stick_1x - stick_4x + stick_2y;

	//---- FEEDER BUTTON ----//
	if (vexRT[Btn5U] == 1)
		motor[magazine] = 50;
	else if (vexRT[Btn5D] == 1)
		motor[magazine] = -50;
	else
		motor[magazine] = 0;
}

void ShooterStartSoft(int speed){
	int minSpeed = 20;
	int step = 2;
	int currentSpeed = minSpeed;
	//while (currentSpeed < speed){
	//	currentSpeed += step;
	//	motor[shooterLeft] = currentSpeed;
	//	motor[shooterRight] = currentSpeed;
	//	wait1Msec(10);
	//}
	motor[shooterLeft] = speed;
	motor[shooterRight] = speed;
}

void autoShooterStartSoft(int speed){
	int minSpeed = 20;
	int step = 2;
	int currentSpeed = minSpeed;
	while (currentSpeed < speed){
		currentSpeed += step;
		motor[shooterLeft] = currentSpeed;
		motor[shooterRight] = currentSpeed;
		wait1Msec(10);
	}
	motor[shooterLeft] = speed;
	motor[shooterRight] = speed;
}


void shooterAdjust(int speedLeftPrevious, int speedRightPrevious, int speedLeftNew, int speedRightNew){
	int step = 2;
	int currentLeftSpeed = speedLeftPrevious;
	int currentRightSpeed = speedRightPrevious;
	if (abs(speedLeftPrevious - speedLeftNew) > 40){
		while (currentLeftSpeed < speedLeftNew){
			currentLeftSpeed += step;
			motor[shooterLeft] = currentLeftSpeed;
			wait1Msec(10);
		}
	}
	if (abs(speedRightPrevious - speedRightNew) > 40){
		while (currentRightSpeed < speedRightNew){
			currentRightSpeed += step;
			motor[shooterRight] = currentRightSpeed;
			wait1Msec(10);
		}

	}
	motor[shooterLeft] = speedLeftNew;
	motor[shooterRight] = speedRightNew;
}

int PID(int adjSpeed)	{
	//----------------SHOOTER VARIABLES----------------//
	int leftEncoderErrorOld;
	int rightEncoderErrorOld;
	int leftEncoderDerivativeError;
	int rightEncoderDerivativeError;
	int leftEncoderSpeedOld;
	int rightEncoderSpeedOld;
	int targetSpeed = adjSpeed / 6;
// ------------ ALGORITHM ---------------//
	leftEncoderSpeed = -SensorValue[leftShooterEncoder];
	rightEncoderSpeed = SensorValue[rightShooterEncoder];
	leftEncoderError = targetSpeed - (leftEncoderSpeed - leftEncoderSpeedOld);
	rightEncoderError = targetSpeed - (rightEncoderSpeed - rightEncoderSpeedOld);
	leftEncoderDerivativeError = leftEncoderError - leftEncoderErrorOld;
	rightEncoderDerivativeError = rightEncoderError - rightEncoderErrorOld;
	leftEncoderErrorOld = leftEncoderError;
	rightEncoderErrorOld = rightEncoderError;
	leftVelocity = leftVelocity + proportion*leftEncoderError / 20 + derivative*leftEncoderDerivativeError / 4;
	rightVelocity = rightVelocity + proportion*rightEncoderError / 20 + derivative*rightEncoderDerivativeError / 4;
	leftEncoderSpeedOld = leftEncoderSpeed;
	rightEncoderSpeedOld = rightEncoderSpeed;
	wait10Msec(2);
	return leftVelocity;
	return rightVelocity;
}

// task userControl()	{

task main()	{
	while (true)	{
			userDrive();				// CALLING FOR DRIVER JOYSTICK CONTROLS
			motor[intake] = 100;	//
	//----------------------RESET Shooter Encoders!------------------//
	SensorValue[leftShooterEncoder] = 0;
	SensorValue[rightShooterEncoder] = 0;
	//-----------------------SHOOTER CONTROLS-----------------------//
	//off button switch?

	shooterStartSoft(shooterSpeedGoal);
	// PID(shooterSpeedGoal);
	shooterLeftSpeed = leftVelocity;
	shooterRightSpeed = rightVelocity;
	if (vexRT[Btn7U] == 1){
		shooterLeftSpeedPrevious = shooterLeftSpeed;
		shooterRightSpeedPrevious = shooterRightSpeed;
		shooterSpeedGoal = shooterSpeedGoal + 2;
		PID(shooterSpeedGoal);
		shooterLeftSpeed = leftVelocity;
		shooterRightSpeed = rightVelocity;
		shooterAdjust(shooterLeftSpeedPrevious, shooterRightSpeedPrevious, shooterLeftSpeed, shooterRightSpeed);
	}
	if (vexRT[Btn7D] == 1){
		shooterLeftSpeedPrevious = shooterLeftSpeed;
		shooterRightSpeedPrevious = shooterRightSpeed;
		shooterSpeedGoal = shooterSpeedGoal - 2;
		PID(shooterSpeedGoal);
		shooterLeftSpeed = leftVelocity;
		shooterRightSpeed = rightVelocity;
		shooterAdjust(shooterLeftSpeedPrevious, shooterRightSpeedPrevious, shooterLeftSpeed, shooterRightSpeed);
	}
	if (vexRT[Btn6U] == 1)	{
		motor[intake] = -100;
	}
//	wait1Msec(20);
	}	// end while statement
}	//end program
